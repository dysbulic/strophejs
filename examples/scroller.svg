<?xml version="1.0" encoding="UTF-8"?>
<svg viewBox="-50 -50 100 100" width="100%" height="100%"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:html="http://www.w3.org/1999/xhtml"
     xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Scroller Interface</title>
  <defs>
      <script type="text/javascript"><![CDATA[
        var def = { userId : '例如' }
      ]]></script>
      <script type="text/javascript" xlink:href=".../lib/tip/pointers.js"/>
      <script type="text/javascript" xlink:href=".../lib/tip/Array.each.js"/>
      <script type="text/javascript" xlink:href=".../lib/tip/MutableString.js"/>
      <script type="text/javascript" xlink:href=".../lib/tip/List.js"/>
      
      <script type="text/javascript" xlink:href=".../lib/jquery/jquery.js"/>
      <script type="application/javascript" xlink:href=".../lib/tip/__.jquery"/>

      <style type="text/css">
      </style>
      <!---->
      <script type="text/javascript"><![CDATA[
          var state = new List( {
              'tixel.capture.frequency.mHz' : .01 * 1000,
          } )
          ;
          ( function() {
              //var state′ = new Suplist( state )
              state.__.set( {
                  'connection.username' : 'mimis.test@gmail.com',
                  'connection.password' : 'mimistest',
                  'connection.server' : 'talk.google.com',
              } )
          } )()

          function Box() {
              var ctr = 
              this.$rect = $.__.$('<rect/>')
              this.__defineGetter__( 'width', function() { return this.$rect.attr( 'width' ) } )
              this.__defineSetter__( 'width', function(val) {
                  this.$rect.attr( 'x', -val / 2 )
                  return this.$rect.attr( 'width', val )
              } )
              this.__defineGetter__( 'height', function() { return this.$rect.attr( 'height' ) } )
              this.__defineSetter__( 'height', function(val) {
                  this.$rect.attr( 'y', -val / 2 )
                  return this.$rect.attr( 'height', val )
              } )
          }

          var box = new Box()
          $.__.$('#').append( box.$rect )

          var scene = new List()
          ;
          ( function() {
              var interval = {
                  id: undefined,
              }

              function once() {
                  // ToDo: capture metrics about execution times
                  //        and attempt to learn impression.display.time
                  //        which is the time that the first 'display'
                  //        event will pass through
                  state.__.set( new List( {
                      'impression.configuration.time.start' : ( new Date() ).getTime(),
                      'impression.display.time.predicted' : ( new Date() ).getTime() + 20,
                      'impression.state' : 'configuration',
                  } ) )
                  var count = 0
                  do {
                      state.__.set( new List( {
                          'impression.configuration.done' : true,
                      } ) )
                      //console.log( 'Starting: once: config:' + state.__.get('impression.configuration.done') )
                      this.__.impress.apply( state )
                      //console.log( 'Finished: once: config:' + state.__.get('impression.configuration.done') )
                  } while( ++count < 100
                           && ! state[ 'impression.configuration.done' ] )
                  state.__.set( {
                      'impression.display.time' : ( new Date() ).getTime(),
                      'impression.configuration.loop.count' : count,
                      'impression.configuration.time' : (
                          ( new Date() ).getTime()
                          + state.__.get( 'tixel.capture.frequency.mHz' )
                      ),
                      'impression.state' : 'display',
                  } )
                  do {
                      state.__.set( new List( {
                          'impression.display.done' : true
                      } ) )
                      this.__.impress.apply( state )
                      //console.log( 'Finished: once: display:' + state.__.get('impression.display.done') )
                  } while( ++count < 100
                           && ! state[ 'impression.display.done' ] )
                  return state
              }
              
              scene.__defineGetter__( 'once', once )
              scene.__defineGetter__( 'go', function() {
                  if( interval.id === undefined ) {
                      var self = this
                      interval.id =
                          setInterval( function() {
                              once.apply( self, arguments )
                          },
                                       state.__.get( 'tixel.capture.frequency.mHz' ) )
                  }
                  return this
              } )
              scene.__defineGetter__( 'stop', function() {
                  if( interval.id !== undefined ) {
                      clearInterval( interval.id )
                      interval.id = undefined
                  }
                  return this
              } )
          } )()
          
          var tixels = new List()

          scene.__.merge( [ {
              impress : function( state ) {
                  if( tixels.__.count == 0 ) {
                      var time = new Date().getTime()
                      tixels.__.add( {
                          obj : box,
                          prop : 'height',
                          time : {
                              start : time + 50,
                              end : time + 1000,
                          },
                          val : {
                              start : 0,
                              end : 1,
                          },
                      } )
                      tixels.__.add( {
                          obj : box,
                          prop : 'width',
                          time : {
                              start : time,
                              end : time + 500,
                          },
                          val : {
                              start : 0,
                              end : 25,
                          },
                      } )
                      tixels.__.add( {
                          obj : box,
                          prop : 'height',
                          time : {
                              start : time + 500,
                              end : time + 1000,
                          },
                          val : {
                              start : 0,
                              end : 25,
                          },
                      } )
                  }
              }
          }, {
              impress : function( state ) {
                  tixels.__.each( function( txl ) {
                      var time = ( new Date() ).getTime()
                      if( time > txl.time.start && time <= txl.time.end
                          || time >= txl.time.end && ! txl.done ) {
                          txl.time.delta = ( txl.time.delta
                                             || txl.time.end - txl.time.start )
                          var offset = ( time >= txl.time.end
                                         ? 1
                                         : ( ( time - txl.time.start )
                                             / txl.time.delta ) )
                          txl.val.delta = ( txl.val.delta
                                            || txl.val.end - txl.val.start )
                          txl.obj[ txl.prop ] = 
                              txl.val.start + offset * txl.val.delta
                      }
                  } )
              }
          } ] )
          console.log( 'script.once:' )
          console.log( scene.go )
      ]]></script>
      <style type="text/css">
        rect { fill: #F0F0F0; fill-opacity: .75;
               stroke-width: .3; stroke: black; stroke-opacity: .5 }
      </style>
  </defs>
  <g class="box">
    
  </g>
</svg>
